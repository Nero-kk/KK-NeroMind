/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/history/SelectNodeCommand.ts
var SelectNodeCommand_exports = {};
__export(SelectNodeCommand_exports, {
  SelectNodeCommand: () => SelectNodeCommand
});
var SelectNodeCommand;
var init_SelectNodeCommand = __esm({
  "src/history/SelectNodeCommand.ts"() {
    SelectNodeCommand = class {
      constructor(newNodeId) {
        this.newNodeId = newNodeId;
        this.description = "Select node";
        this.previousNodeId = null;
        this.isFirstExecution = true;
      }
      /**
       * execute: 노드 선택 상태 변경
       *
       * Phase 5.1:
       * - persistentState.ui.selectedNodeId 변경 (Undo 대상)
       * - lastSelectedNodeId는 ephemeral에 유지 (Undo 비대상)
       */
      execute(context) {
        if (this.isFirstExecution) {
          this.previousNodeId = context.persistent.ui.selectedNodeId;
          this.isFirstExecution = false;
        }
        if (context.persistent.ui.selectedNodeId !== null) {
          context.ephemeral.lastSelectedNodeId = context.persistent.ui.selectedNodeId;
        }
        context.persistent.ui.selectedNodeId = this.newNodeId;
      }
      /**
       * undo: 이전 선택 상태로 복원
       *
       * Phase 5.1:
       * - persistentState.ui.selectedNodeId를 previousNodeId로 복원
       */
      undo(context) {
        context.persistent.ui.selectedNodeId = this.previousNodeId;
      }
    };
  }
});

// src/history/MoveNodeCommand.ts
var MoveNodeCommand_exports = {};
__export(MoveNodeCommand_exports, {
  MoveNodeCommand: () => MoveNodeCommand
});
var MoveNodeCommand;
var init_MoveNodeCommand = __esm({
  "src/history/MoveNodeCommand.ts"() {
    MoveNodeCommand = class {
      constructor(nodeId, from, to) {
        this.nodeId = nodeId;
        this.from = from;
        this.to = to;
        this.description = "Move node";
      }
      /**
       * execute: 노드 위치를 to로 이동
       *
       * 동작:
       * 1. 노드를 persistent state에서 조회
       * 2. position을 to로 변경
       * 3. updatedAt 자동 갱신
       */
      execute(context) {
        const node = context.persistent.graph.nodes.get(this.nodeId);
        if (!node) {
          return;
        }
        node.position.x = this.to.x;
        node.position.y = this.to.y;
        node.updatedAt = Date.now();
      }
      /**
       * undo: 노드 위치를 from으로 복원
       *
       * 동작:
       * 1. 노드를 persistent state에서 조회
       * 2. position을 from으로 복원
       * 3. updatedAt 자동 갱신
       */
      undo(context) {
        const node = context.persistent.graph.nodes.get(this.nodeId);
        if (!node) {
          return;
        }
        node.position.x = this.from.x;
        node.position.y = this.from.y;
        node.updatedAt = Date.now();
      }
    };
  }
});

// src/history/ClearSelectionCommand.ts
var ClearSelectionCommand_exports = {};
__export(ClearSelectionCommand_exports, {
  ClearSelectionCommand: () => ClearSelectionCommand
});
var ClearSelectionCommand;
var init_ClearSelectionCommand = __esm({
  "src/history/ClearSelectionCommand.ts"() {
    ClearSelectionCommand = class {
      constructor() {
        this.description = "Clear selection";
        this.previousNodeId = null;
        this.isFirstExecution = true;
      }
      /**
       * execute: 선택 해제 (null 설정)
       *
       * Phase 5.1:
       * - persistentState.ui.selectedNodeId = null
       */
      execute(context) {
        if (this.isFirstExecution) {
          this.previousNodeId = context.persistent.ui.selectedNodeId;
          this.isFirstExecution = false;
        }
        context.persistent.ui.selectedNodeId = null;
      }
      /**
       * undo: 이전 선택 상태로 복원
       *
       * Phase 5.1:
       * - persistentState.ui.selectedNodeId를 previousNodeId로 복원
       */
      undo(context) {
        context.persistent.ui.selectedNodeId = this.previousNodeId;
      }
    };
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => NeroMindPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");

// src/views/NeroMindView.ts
var import_obsidian = require("obsidian");

// src/state/StateManager.ts
var StateManager = class {
  constructor() {
    this.persistentState = this.createInitialPersistentState();
    this.ephemeralState = this.createInitialEphemeralState();
  }
  /**
   * EventBus 주입 (선택적)
   * - 주입되지 않아도 기존 동작을 유지해야 하므로 optional 로 둔다.
   */
  setEventBus(eventBus) {
    this.eventBus = eventBus;
  }
  /**
   * 현재 상태의 읽기 전용 스냅샷을 반환
   * - 외부 소비자는 반환값을 수정하더라도 내부 상태에 영향 없음
   * - 내부 배열까지 deep freeze하여 불변성 보장
   *
   * Phase 5.1: selectedNodeId는 persistentState.ui에서 가져옴
   */
  getSnapshot() {
    const nodes = Object.freeze(
      Array.from(this.persistentState.graph.nodes.values()).map(
        (node) => this.cloneNode(node)
      )
    );
    const edges = Object.freeze(
      Array.from(this.persistentState.graph.edges.values()).map(
        (edge) => ({ ...edge })
      )
    );
    const pinnedNodeIds = Object.freeze(
      Array.from(this.persistentState.pinnedNodes)
    );
    const collapsedNodeIds = Object.freeze(
      Array.from(this.ephemeralState.collapsedNodes)
    );
    return Object.freeze({
      nodes,
      edges,
      rootId: this.persistentState.graph.rootId,
      pinnedNodeIds,
      collapsedNodeIds,
      selectedNodeId: this.persistentState.ui.selectedNodeId,
      // Phase 5.1: persistent
      editingNodeId: this.ephemeralState.editingNodeId
    });
  }
  /**
   * 커맨드를 적용하고 최신 스냅샷을 반환
   * - 단방향 흐름: 입력 → Command → State → Snapshot
   */
  apply(command) {
    command.execute(this.getContext());
    return this.getSnapshot();
  }
  /**
   * 초기 영구 상태 생성
   *
   * Phase 5.1: ui 상태 추가
   */
  createInitialPersistentState() {
    return {
      schemaVersion: 1,
      graph: {
        nodes: /* @__PURE__ */ new Map(),
        edges: /* @__PURE__ */ new Map(),
        rootId: ""
      },
      layout: {
        viewport: {
          x: 0,
          y: 0,
          zoom: 1
        },
        nodePositions: /* @__PURE__ */ new Map()
      },
      settings: {
        autoAlign: true,
        centerOnCreate: true,
        minimap: {
          enabled: true,
          size: "medium",
          opacity: 0.9
        }
      },
      pinnedNodes: /* @__PURE__ */ new Set(),
      ui: {
        selectedNodeId: null
        // Phase 5.1: 선택 상태 (Undo 대상)
      }
    };
  }
  /**
   * 초기 임시 상태 생성
   */
  createInitialEphemeralState() {
    return {
      selectedNodeId: null,
      editingNodeId: null,
      collapsedNodes: /* @__PURE__ */ new Set(),
      dragState: null,
      lastSelectedNodeId: null
    };
  }
  // =========================================================================
  // Getters (Read-Only Interface)
  // =========================================================================
  /**
   * 노드 조회
   * - Readonly 반환으로 외부에서 내부 상태 직접 수정 방지
   */
  getNode(nodeId) {
    return this.persistentState.graph.nodes.get(nodeId);
  }
  /**
   * 모든 노드 조회
   * - Readonly 반환으로 외부에서 내부 상태 직접 수정 방지
   */
  getAllNodes() {
    return Array.from(this.persistentState.graph.nodes.values());
  }
  /**
   * 루트 노드 조회
   * - Readonly 반환으로 외부에서 내부 상태 직접 수정 방지
   */
  getRootNode() {
    const rootId = this.persistentState.graph.rootId;
    if (!rootId)
      return null;
    return this.getNode(rootId) || null;
  }
  /**
   * 엣지 조회
   * - Readonly 반환으로 외부에서 내부 상태 직접 수정 방지
   */
  getEdge(edgeId) {
    return this.persistentState.graph.edges.get(edgeId);
  }
  /**
   * 선택된 노드 ID 조회
   */
  getSelectedNodeId() {
    return this.ephemeralState.selectedNodeId;
  }
  /**
   * 편집 중인 노드 ID 조회
   */
  getEditingNodeId() {
    return this.ephemeralState.editingNodeId;
  }
  // =========================================================================
  // Setters (Write-Only Interface)
  // Phase 2+: Command 패턴으로 변환 예정
  // =========================================================================
  /**
   * 노드 추가
   *
   * 제약사항:
   * - 첫 번째 노드는 자동으로 루트 노드로 설정됨
   * - 중복 ID 검증 없음 (호출자 책임)
   * - 이벤트 발행 없음 (Phase 2+)
   */
  addNode(node) {
    this.persistentState.graph.nodes.set(node.id, node);
    if (!this.persistentState.graph.rootId) {
      this.persistentState.graph.rootId = node.id;
    }
    this.emitSafe("nodeCreated", { node });
  }
  /**
   * 노드 제거
   *
   * ⚠️ 경고: 현재 불완전한 구현
   * - 연결된 엣지 제거 안 됨 (고아 엣지 발생)
   * - 자식 노드 참조 업데이트 안 됨
   * - 루트 노드 제거 시 그래프 무효화 가능
   * - Phase 2+에서 완전한 구현 예정
   */
  removeNode(nodeId) {
    this.persistentState.graph.nodes.delete(nodeId);
    this.emitSafe("nodeDeleted", { nodeId });
  }
  /**
   * 노드 업데이트
   *
   * 제약사항:
   * - nodeId가 존재하지 않으면 조용히 실패 (undefined 반환)
   * - updates 유효성 검증 없음 (잘못된 값 방지 안 됨)
   * - childIds 등 관계 필드 수정 시 그래프 무결성 보장 안 됨
   * - updatedAt은 자동 갱신됨
   */
  updateNode(nodeId, updates) {
    const node = this.persistentState.graph.nodes.get(nodeId);
    if (!node)
      return;
    Object.assign(node, updates);
    node.updatedAt = Date.now();
    this.emitSafe("nodeUpdated", { node });
  }
  /**
   * 노드 선택 (Phase 4.x: Command 패턴)
   *
   * 제약사항:
   * - nodeId 존재 여부 검증 안 됨
   * - 이전 선택은 lastSelectedNodeId에 자동 저장됨
   * - null 전달 시 선택 해제
   *
   * Phase 4.x:
   * - SelectNodeCommand를 통해 apply() 경로 사용
   * - HistoryManager 통합은 Phase 4.x+ 예정
   */
  selectNode(nodeId) {
    const { SelectNodeCommand: SelectNodeCommand2 } = (init_SelectNodeCommand(), __toCommonJS(SelectNodeCommand_exports));
    const command = new SelectNodeCommand2(nodeId);
    this.apply(command);
  }
  /**
   * 노드 편집 모드 진입
   *
   * 제약사항:
   * - nodeId 존재 여부 검증 안 됨
   * - 선택 상태와 독립적 (편집 중이어도 선택되지 않을 수 있음)
   * - null 전달 시 편집 모드 종료
   * - 동시에 여러 노드 편집 불가 (마지막 호출만 유효)
   */
  setEditingNode(nodeId) {
    this.ephemeralState.editingNodeId = nodeId;
  }
  /**
   * 노드 이동 (Phase 4.x: Command 패턴)
   *
   * 제약사항:
   * - nodeId 존재 여부 검증 안 됨
   * - 레이아웃 계산은 외부에서 수행
   * - 다른 노드에 영향 주지 않음
   *
   * Phase 4.x:
   * - MoveNodeCommand를 통해 apply() 경로 사용
   * - 현재 위치를 from으로 자동 캡처
   * - HistoryManager 통합은 Phase 4.x+ 예정
   *
   * @param nodeId - 이동할 노드 ID
   * @param toX - 목표 x 좌표
   * @param toY - 목표 y 좌표
   */
  moveNode(nodeId, toX, toY) {
    const node = this.persistentState.graph.nodes.get(nodeId);
    if (!node) {
      return;
    }
    const from = { x: node.position.x, y: node.position.y };
    const to = { x: toX, y: toY };
    const { MoveNodeCommand: MoveNodeCommand2 } = (init_MoveNodeCommand(), __toCommonJS(MoveNodeCommand_exports));
    const command = new MoveNodeCommand2(nodeId, from, to);
    this.apply(command);
  }
  /**
   * 선택 해제 (Phase 5.1: Command 패턴)
   *
   * Phase 5.1:
   * - ClearSelectionCommand를 통해 apply() 경로 사용
   * - Undo/Redo 대상
   */
  clearSelection() {
    const { ClearSelectionCommand: ClearSelectionCommand2 } = (init_ClearSelectionCommand(), __toCommonJS(ClearSelectionCommand_exports));
    const command = new ClearSelectionCommand2();
    this.apply(command);
  }
  /**
   * 현재 상태 컨텍스트 (Command 전용)
   */
  getContext() {
    return {
      persistent: this.persistentState,
      ephemeral: this.ephemeralState
    };
  }
  /**
   * 스냅샷용 노드 복제
   */
  cloneNode(node) {
    return {
      ...node,
      position: { ...node.position },
      childIds: [...node.childIds]
    };
  }
  /**
   * EventBus에 안전하게 발행
   * - 설정되지 않았거나 핸들러 에러 발생 시 상태 변경에 영향을 주지 않는다.
   */
  emitSafe(eventName, payload) {
    if (!this.eventBus)
      return;
    try {
      this.eventBus.emit(eventName, payload);
    } catch (e) {
    }
  }
  // =========================================================================
  // 직렬화/역직렬화 (Phase 3: 파일 저장용)
  // =========================================================================
  /**
   * 상태를 JSON으로 직렬화
   */
  serialize() {
    const data = {
      schemaVersion: this.persistentState.schemaVersion,
      nodes: Array.from(this.persistentState.graph.nodes.entries()),
      edges: Array.from(this.persistentState.graph.edges.entries()),
      rootId: this.persistentState.graph.rootId,
      layout: {
        viewport: this.persistentState.layout.viewport,
        nodePositions: Array.from(
          this.persistentState.layout.nodePositions.entries()
        )
      },
      settings: this.persistentState.settings,
      pinnedNodes: Array.from(this.persistentState.pinnedNodes)
    };
    return JSON.stringify(data, null, 2);
  }
  /**
   * JSON에서 상태 복원
   */
  deserialize(jsonString) {
    try {
      const data = JSON.parse(jsonString);
      this.persistentState.schemaVersion = data.schemaVersion || 1;
      this.persistentState.graph.nodes = new Map(data.nodes || []);
      this.persistentState.graph.edges = new Map(data.edges || []);
      this.persistentState.graph.rootId = data.rootId || "";
      if (data.layout) {
        this.persistentState.layout.viewport = data.layout.viewport || {
          x: 0,
          y: 0,
          zoom: 1
        };
        this.persistentState.layout.nodePositions = new Map(
          data.layout.nodePositions || []
        );
      }
      this.persistentState.settings = data.settings || this.persistentState.settings;
      this.persistentState.pinnedNodes = new Set(data.pinnedNodes || []);
    } catch (error) {
      console.error("Failed to deserialize state:", error);
    }
  }
  // =========================================================================
  // Disposable
  // =========================================================================
  destroy() {
    this.persistentState.graph.nodes.clear();
    this.persistentState.graph.edges.clear();
    this.persistentState.layout.nodePositions.clear();
    this.persistentState.pinnedNodes.clear();
    this.ephemeralState.collapsedNodes.clear();
  }
};

// src/history/HistoryManager.ts
var HistoryManager = class {
  /**
   * HistoryManager 생성자
   *
   * @param stateManager - 래핑할 StateManager 인스턴스
   *
   * 책임:
   * - StateManager 참조 저장
   * - 빈 히스토리 큐 초기화
   *
   * 비책임:
   * - StateManager의 초기 상태 설정 (호출자 책임)
   */
  constructor(stateManager) {
    this.commandQueue = [];
    this.MAX_HISTORY = 10;
    this.stateManager = stateManager;
  }
  /**
   * UndoableCommand 실행
   *
   * 책임:
   * 1. StateManager.apply(command) 호출로 명령 실행
   * 2. 실행된 커맨드를 히스토리 큐에 추가
   * 3. MAX_HISTORY 초과 시 가장 오래된 커맨드 제거
   * 4. 현재 상태 스냅샷 반환
   *
   * @param command - 실행할 UndoableCommand
   * @returns 명령 실행 후의 StateSnapshot
   *
   * 비책임:
   * - 커맨드 유효성 검증 (구현체의 책임)
   * - StateManager 내부 상태 직접 조작
   * - EventBus 발행
   */
  execute(command) {
    const snapshot = this.stateManager.apply(command);
    this.commandQueue.push(command);
    if (this.commandQueue.length > this.MAX_HISTORY) {
      this.commandQueue.shift();
    }
    return snapshot;
  }
  /**
   * 마지막 작업 취소
   *
   * 책임:
   * 1. 히스토리 큐에서 마지막 커맨드 추출 (pop)
   * 2. Inverse Operation 패턴으로 undo() 실행
   * 3. StateManager을 통해 역방향 변경 적용
   * 4. 복원된 상태 스냅샷 반환
   *
   * @returns 취소 후의 StateSnapshot
   * @throws Error - 취소할 히스토리가 없으면 에러
   *
   * 비책임:
   * - undo 가능 여부 사전 확인 (canUndo 메서드 별도 제공)
   * - Redo 기능
   * - EventBus 발행
   */
  undo() {
    if (!this.canUndo()) {
      throw new Error("No history to undo");
    }
    const command = this.commandQueue.pop();
    const undoWrapper = {
      description: `Undo: ${command.description}`,
      execute: (context) => {
        command.undo(context);
      }
    };
    const snapshot = this.stateManager.apply(undoWrapper);
    return snapshot;
  }
  /**
   * 취소 가능 여부
   *
   * @returns true면 undo() 호출 가능, false면 히스토리 없음
   *
   * 책임:
   * - 커맨드 큐 상태 확인
   *
   * 비책임:
   * - StateManager 상태 확인 (irrelevant)
   * - Redo 가능 여부 확인
   */
  canUndo() {
    return this.commandQueue.length > 0;
  }
  /**
   * 현재 히스토리 크기
   *
   * @returns 저장된 커맨드 개수
   *
   * 용도:
   * - UI에서 히스토리 개수 표시
   * - 디버깅
   * - 테스트
   */
  getHistorySize() {
    return this.commandQueue.length;
  }
  /**
   * 히스토리 초기화 (선택사항)
   *
   * 용도:
   * - 새 파일 로드 시 이전 히스토리 제거
   * - 테스트
   *
   * 책임:
   * - 모든 커맨드 큐 비우기
   *
   * 비책임:
   * - StateManager 상태 초기화
   */
  clearHistory() {
    this.commandQueue.length = 0;
  }
  /**
   * StateManager 직접 접근 (고급 사용)
   *
   * 용도:
   * - Renderer 등에서 현재 상태 조회
   * - StateManager의 getSnapshot() 등 직접 호출
   *
   * 책임:
   * - StateManager 인스턴스 반환
   *
   * 주의:
   * - 이 메서드로 StateManager.apply() 호출 시 히스토리에 기록되지 않음
   * - 히스토리가 필요하면 HistoryManager.execute() 사용
   */
  getStateManager() {
    return this.stateManager;
  }
  /**
   * 리소스 정리
   *
   * 책임:
   * - 히스토리 큐 비우기
   * - StateManager 정리
   *
   * 비책임:
   * - StateManager는 자신의 destroy()를 호출하므로 여기서는 관리 해제만
   */
  destroy() {
    this.commandQueue.length = 0;
    this.stateManager.destroy();
  }
};

// src/events/EventBus.ts
var EventBus = class {
  constructor() {
    this.listeners = /* @__PURE__ */ new Map();
  }
  /**
   * 이벤트 구독
   * @returns 구독 해제 함수
   */
  on(eventName, handler) {
    if (!eventName || typeof eventName !== "string") {
      throw new Error("EventBus.on: eventName must be a non-empty string");
    }
    if (typeof handler !== "function") {
      throw new Error("EventBus.on: handler must be a function");
    }
    let handlers = this.listeners.get(eventName);
    if (!handlers) {
      handlers = /* @__PURE__ */ new Set();
      this.listeners.set(eventName, handlers);
    }
    handlers.add(handler);
    return () => {
      const current = this.listeners.get(eventName);
      if (!current)
        return;
      current.delete(handler);
      if (current.size === 0) {
        this.listeners.delete(eventName);
      }
    };
  }
  /**
   * 이벤트 발행
   */
  emit(eventName, payload) {
    if (!eventName || typeof eventName !== "string") {
      throw new Error("EventBus.emit: eventName must be a non-empty string");
    }
    if (payload === void 0) {
      throw new Error("EventBus.emit: payload is undefined");
    }
    const handlers = this.listeners.get(eventName);
    if (!handlers)
      return;
    for (const handler of handlers) {
      try {
        handler(payload);
      } catch (e) {
      }
    }
  }
};

// src/types/index.ts
var DEFAULT_SETTINGS = {
  centerOnNodeCreate: true,
  autoAlign: true,
  minimap: {
    enabled: true,
    size: "medium",
    opacity: 0.9
  },
  theme: "light",
  animationDuration: 200,
  nodeGap: {
    horizontal: 100,
    vertical: 60
  }
};
var SVG_NS = "http://www.w3.org/2000/svg";

// src/layout/CenterRootLayout.ts
var HORIZONTAL_GAP = 100;
var VERTICAL_GAP = 60;
function computeCenterRootLayout(nodes, viewport) {
  const nodeMap = /* @__PURE__ */ new Map();
  for (const node of nodes) {
    nodeMap.set(node.id, node);
  }
  const root = nodes.find((n) => n.parentId === null);
  if (!root) {
    return {};
  }
  const tree = buildTree(root.id, nodeMap);
  const positions = {};
  const rootX = viewport.width / 2;
  const rootY = viewport.height / 2;
  positions[root.id] = { x: rootX, y: rootY };
  console.log("[CenterRootLayout] \uB8E8\uD2B8 \uB178\uB4DC \uC911\uC559 \uBC30\uCE58:", {
    viewport,
    rootId: root.id,
    rootPosition: { x: rootX, y: rootY }
  });
  const children = tree.children;
  for (let i = 0; i < children.length; i++) {
    const child = children[i];
    const side = i % 2 === 0 ? "right" : "left";
    layoutSubtree(child, side, rootX, rootY, positions, nodeMap);
  }
  return positions;
}
function buildTree(nodeId, nodeMap) {
  const node = nodeMap.get(nodeId);
  if (!node) {
    throw new Error(`Node not found: ${nodeId}`);
  }
  const children = [];
  for (const childId of node.childIds) {
    children.push(buildTree(childId, nodeMap));
  }
  return {
    id: nodeId,
    parentId: node.parentId,
    children
  };
}
function layoutSubtree(tree, side, parentX, parentY, positions, nodeMap) {
  const x = side === "right" ? parentX + HORIZONTAL_GAP : parentX - HORIZONTAL_GAP;
  const totalHeight = calculateSubtreeHeight(tree);
  const y = parentY;
  positions[tree.id] = { x, y };
  if (tree.children.length > 0) {
    let currentY = y - totalHeight / 2;
    for (const child of tree.children) {
      const childHeight = calculateSubtreeHeight(child);
      const childCenterY = currentY + childHeight / 2;
      layoutSubtree(child, side, x, childCenterY, positions, nodeMap);
      currentY += childHeight + VERTICAL_GAP;
    }
  }
}
function calculateSubtreeHeight(tree) {
  if (tree.children.length === 0) {
    return 0;
  }
  let totalHeight = 0;
  for (let i = 0; i < tree.children.length; i++) {
    const childHeight = calculateSubtreeHeight(tree.children[i]);
    totalHeight += Math.max(childHeight, 0);
    if (i < tree.children.length - 1) {
      totalHeight += VERTICAL_GAP;
    }
  }
  return totalHeight;
}

// src/layout/NodeTextLayout.ts
function computeTextLayout(text, maxWidth, metrics = { fontSize: 12, fontFamily: "sans-serif" }) {
  const { fontSize } = metrics;
  const lineHeight = fontSize * 1.4;
  if (!text || text.trim() === "") {
    return {
      lines: [""],
      width: 0,
      height: lineHeight
    };
  }
  const words = text.split(/\s+/);
  const lines = [];
  let currentLine = "";
  for (const word of words) {
    const testLine = currentLine ? `${currentLine} ${word}` : word;
    const testWidth = estimateTextWidth(testLine, fontSize);
    if (testWidth <= maxWidth) {
      currentLine = testLine;
    } else {
      if (currentLine === "") {
        const parts = splitLongWord(word, maxWidth, fontSize);
        for (let i = 0; i < parts.length - 1; i++) {
          lines.push(parts[i]);
        }
        currentLine = parts[parts.length - 1];
      } else {
        lines.push(currentLine);
        currentLine = word;
      }
    }
  }
  if (currentLine) {
    lines.push(currentLine);
  }
  const actualWidth = Math.max(
    ...lines.map((line) => estimateTextWidth(line, fontSize))
  );
  const actualHeight = lines.length * lineHeight;
  return {
    lines,
    width: actualWidth,
    height: actualHeight
  };
}
function estimateTextWidth(text, fontSize) {
  let totalWidth = 0;
  for (const char of text) {
    const code = char.charCodeAt(0);
    if (code >= 44032 && code <= 55203) {
      totalWidth += fontSize * 1;
    } else {
      totalWidth += fontSize * 0.6;
    }
  }
  return totalWidth;
}
function splitLongWord(word, maxWidth, fontSize) {
  const parts = [];
  let current = "";
  for (const char of word) {
    const testWord = current + char;
    const testWidth = estimateTextWidth(testWord, fontSize);
    if (testWidth <= maxWidth) {
      current += char;
    } else {
      if (current) {
        parts.push(current);
      }
      current = char;
    }
  }
  if (current) {
    parts.push(current);
  }
  return parts.length > 0 ? parts : [word];
}

// src/rendering/Renderer.ts
var Renderer = class {
  constructor(svgElement) {
    this.rafId = null;
    // Phase 5: Drag 상태
    this.draggingNodeId = null;
    this.dragOffset = { x: 0, y: 0 };
    this.dragStartPosition = { x: 0, y: 0 };
    // Phase 5: StateManager 참조 (drag 완료 시 moveNode 호출용)
    this.stateManager = null;
    /**
     * Phase 6.1: 초기 viewport 캐싱
     *
     * 책임:
     * - 플러그인 최초 로딩 시 1회만 viewport 크기 계산
     * - 이후 resize/pan/zoom 시 viewport 재계산 금지
     * - 노드의 절대 위치를 고정하여 transform-layer만 변경
     *
     * 이유:
     * - resize 시 layout 재계산하면 노드 위치가 변경됨
     * - pan/zoom은 transform-layer로 처리해야 함
     * - 초기 위치를 고정하여 일관된 좌표계 유지
     */
    this.initialViewport = null;
    /**
     * pointermove: 드래그 preview (state 변경 ❌)
     *
     * 동작:
     * 1. draggingNodeId 없으면 무시
     * 2. 포인터 위치 → SVG 좌표 변환
     * 3. 새 위치 계산 (포인터 - dragOffset)
     * 4. DOM transform 직접 변경 (state 변경 없음)
     *
     * 핵심: StateManager 호출 ❌, Command 생성 ❌
     */
    this.handlePointerMove = (e) => {
      var _a;
      if (!this.draggingNodeId)
        return;
      const pt = this.svgElement.createSVGPoint();
      pt.x = e.clientX;
      pt.y = e.clientY;
      const svgP = pt.matrixTransform(
        (_a = this.svgElement.getScreenCTM()) == null ? void 0 : _a.inverse()
      );
      const newX = svgP.x - this.dragOffset.x;
      const newY = svgP.y - this.dragOffset.y;
      const nodeGroup = this.svgElement.querySelector(
        `#node-${this.draggingNodeId}`
      );
      if (nodeGroup) {
        nodeGroup.setAttribute("transform", `translate(${newX}, ${newY})`);
      }
    };
    /**
     * pointerup: 드래그 완료 (MoveNodeCommand 생성)
     *
     * 동작:
     * 1. draggingNodeId 없으면 무시
     * 2. 포인터 위치 → SVG 좌표 변환
     * 3. 최종 위치 계산
     * 4. StateManager.moveNode() 호출 (단 1회 Command 생성)
     * 5. 드래그 상태 초기화
     * 6. 전역 리스너 제거
     *
     * 핵심: 여기서만 StateManager.moveNode() 호출
     */
    this.handlePointerUp = (e) => {
      var _a;
      if (!this.draggingNodeId)
        return;
      const pt = this.svgElement.createSVGPoint();
      pt.x = e.clientX;
      pt.y = e.clientY;
      const svgP = pt.matrixTransform(
        (_a = this.svgElement.getScreenCTM()) == null ? void 0 : _a.inverse()
      );
      const finalX = svgP.x - this.dragOffset.x;
      const finalY = svgP.y - this.dragOffset.y;
      if (this.stateManager) {
        this.stateManager.moveNode(this.draggingNodeId, finalX, finalY);
      }
      this.draggingNodeId = null;
      this.dragOffset = { x: 0, y: 0 };
      this.dragStartPosition = { x: 0, y: 0 };
      document.removeEventListener("pointermove", this.handlePointerMove);
      document.removeEventListener("pointerup", this.handlePointerUp);
      document.body.style.cursor = "";
    };
    this.svgElement = svgElement;
    this.setupCanvasBackgroundHandler();
  }
  /**
   * Phase 5: StateManager 주입
   *
   * drag 완료 시 moveNode() 호출을 위해 필요
   * Phase 5.1: 선택 해제를 위한 clearSelection() 호출
   */
  setStateManager(stateManager) {
    this.stateManager = stateManager;
  }
  /**
   * Phase 5.1: Canvas background 클릭 핸들러 설정
   *
   * SVG 빈 공간 클릭 시 선택 해제
   */
  setupCanvasBackgroundHandler() {
    this.svgElement.addEventListener("pointerdown", (e) => {
      const target = e.target;
      if (target === this.svgElement || target.id === "transform-layer") {
        if (this.stateManager) {
          this.stateManager.clearSelection();
        }
      }
    });
  }
  /**
   * StateSnapshot을 SVG로 렌더링
   *
   * Phase 4.0 렌더링 순서:
   * 1. edge-layer: 엣지 먼저 (뒤에 그려짐)
   * 2. node-layer: 노드 나중에 (앞에 그려짐)
   *
   * Phase 6.0 레이아웃 통합:
   * - computeCenterRootLayout 호출하여 실제 렌더 좌표 계산
   * - node.position 대신 layout 결과 사용
   * - viewport는 viewBox 기준 (SVG 내부 좌표계)
   *
   * @param snapshot - 렌더링할 StateSnapshot
   */
  render(snapshot) {
    if (this.initialViewport === null) {
      this.initialViewport = this.getViewportSize();
      console.log("[Renderer.render] \u{1F3AF} \uCD08\uAE30 viewport \uCE90\uC2F1 (1\uD68C\uB9CC):", this.initialViewport);
    }
    const layout = computeCenterRootLayout(snapshot.nodes, this.initialViewport);
    const svgViewBox = this.svgElement.viewBox.baseVal;
    const svgBoundingRect = this.svgElement.getBoundingClientRect();
    console.log("[\u{1F50D} \uC88C\uD45C\uACC4 \uAC80\uC99D]", {
      "viewBox.baseVal": {
        x: svgViewBox.x,
        y: svgViewBox.y,
        width: svgViewBox.width,
        height: svgViewBox.height
      },
      "getBoundingClientRect()": {
        top: svgBoundingRect.top,
        left: svgBoundingRect.left,
        width: svgBoundingRect.width,
        height: svgBoundingRect.height
      },
      "initialViewport (\uCE90\uC2F1\uB428)": this.initialViewport,
      "\uD604\uC7AC \uC2E4\uC81C \uD06C\uAE30\uC640 \uC77C\uCE58 \uC5EC\uBD80": {
        widthMatch: Math.abs(svgBoundingRect.width - this.initialViewport.width) < 1,
        heightMatch: Math.abs(svgBoundingRect.height - this.initialViewport.height) < 1
      }
    });
    if (snapshot.rootId && layout[snapshot.rootId]) {
      const rootPos = layout[snapshot.rootId];
      console.log("[\u{1F50D} \uC88C\uD45C\uACC4 \uAC80\uC99D] \uB8E8\uD2B8 \uB178\uB4DC \uCD5C\uC885 transform:", {
        nodeId: snapshot.rootId,
        x: rootPos.x,
        y: rootPos.y,
        transform: `translate(${rootPos.x}, ${rootPos.y})`
      });
    }
    console.log("[Renderer.render] \uB80C\uB354\uB9C1 \uC2DC\uC791:", {
      viewport: this.initialViewport,
      nodeCount: snapshot.nodes.length,
      rootId: snapshot.rootId,
      layoutSample: Object.keys(layout).length > 0 ? { [snapshot.rootId || "none"]: layout[snapshot.rootId || ""] } : "empty"
    });
    this.renderEdges(snapshot, layout);
    this.renderNodes(snapshot, layout);
  }
  /**
   * Phase 6.0: Viewport 크기 계산
   *
   * 책임:
   * - ✅ 실제 DOM viewport 크기를 기반으로 계산 (getBoundingClientRect)
   * - ✅ viewBox가 아닌 사용자가 보는 실제 화면 기준
   * - ✅ 이 좌표계가 SVG transform 좌표계와 일치함
   *
   * 이유:
   * - viewBox 좌표계와 DOM viewport 좌표계가 다를 수 있음
   * - 사용자가 보는 "시각적 중앙"은 DOM viewport 기준
   * - CenterRootLayout은 이 DOM 좌표계 기준으로 계산해야 정확
   *
   * 검증 체크리스트:
   * ✓ 루트 노드가 항상 시각적 중앙에 오는지
   * ✓ 창 리사이즈 시 재계산 되는지 (render() 호출 시마다 계산)
   * ✓ viewBox 설정과 무관하게 동일한 시각적 결과
   *
   * @returns { width, height } viewport 크기 (DOM 기준)
   */
  getViewportSize() {
    const rect = this.svgElement.getBoundingClientRect();
    return {
      width: rect.width || 800,
      // fallback: 800px
      height: rect.height || 600
      // fallback: 600px
    };
  }
  /**
   * Phase 4.0: 엣지 렌더링
   *
   * Phase 6.0: layout 좌표 사용
   * - node.position 대신 layout[nodeId] 사용
   *
   * 책임:
   * - parentId 기반으로 부모-자식 연결선 렌더링
   * - 레이아웃 결과 좌표 사용
   *
   * @param snapshot - 렌더링할 StateSnapshot
   * @param layout - 레이아웃 계산 결과 좌표
   */
  renderEdges(snapshot, layout) {
    const edgeLayer = this.getOrCreateEdgeLayer();
    this.clearLayer(edgeLayer);
    for (const node of snapshot.nodes) {
      if (node.parentId !== null) {
        const parentPosition = layout[node.parentId];
        const nodePosition = layout[node.id];
        if (parentPosition && nodePosition) {
          const line = this.createLine(parentPosition, nodePosition);
          edgeLayer.appendChild(line);
        }
      }
    }
  }
  /**
   * 노드 렌더링 (Phase 3.4 로직 분리)
   *
   * Phase 4.x: 선택 상태 시각화 추가
   * - snapshot.selectedNodeId 기반으로 선택 노드 강조
   *
   * Phase 5: 드래그 이벤트 리스너 추가
   * - pointerdown 이벤트로 드래그 시작
   *
   * Phase 6.0: layout 좌표 사용 + rounded rect 렌더링
   * - node.position 대신 layout[nodeId] 사용
   * - circle 대신 rounded rect 사용
   * - NodeTextLayout으로 텍스트 크기 계산
   * - 다중 줄 텍스트 지원 (tspan)
   *
   * @param snapshot - 렌더링할 StateSnapshot
   * @param layout - 레이아웃 계산 결과 좌표
   */
  renderNodes(snapshot, layout) {
    const nodeLayer = this.getOrCreateNodeLayer();
    this.clearLayer(nodeLayer);
    for (const node of snapshot.nodes) {
      const nodePosition = layout[node.id];
      if (!nodePosition) {
        console.warn(`[renderNodes] SKIP: layout\uC5D0 \uC88C\uD45C \uC5C6\uC74C (nodeId: ${node.id})`);
        continue;
      }
      const isSelected = node.id === snapshot.selectedNodeId;
      const isDragging = node.id === this.draggingNodeId;
      const textLayout = computeTextLayout(node.content, 200, {
        fontSize: 12,
        fontFamily: "-apple-system, BlinkMacSystemFont, sans-serif"
      });
      const padding = 16;
      const rectWidth = textLayout.width + padding * 2;
      const rectHeight = textLayout.height + padding * 2;
      const nodeGroup = this.createNodeGroup(
        node.id,
        nodePosition.x,
        nodePosition.y
      );
      const rect = this.createRoundedRect(
        rectWidth,
        rectHeight,
        8,
        isSelected,
        isDragging
      );
      nodeGroup.appendChild(rect);
      const text = this.createMultilineText(textLayout.lines);
      nodeGroup.appendChild(text);
      nodeGroup.style.cursor = "grab";
      nodeGroup.addEventListener(
        "pointerdown",
        (e) => this.handlePointerDown(e, node.id, nodePosition)
      );
      nodeLayer.appendChild(nodeGroup);
    }
    console.log("[renderNodes] \uC644\uB8CC:", {
      \uB80C\uB354\uB9C1\uB41C_\uB178\uB4DC_\uAC1C\uC218: nodeLayer.children.length,
      \uC804\uCCB4_\uB178\uB4DC_\uAC1C\uC218: snapshot.nodes.length
    });
  }
  /**
   * Phase 4.0: edge-layer 획득 또는 생성
   *
   * edge-layer는 node-layer보다 먼저 추가되어야 함 (뒤에 렌더링)
   */
  getOrCreateEdgeLayer() {
    let edgeLayer = this.svgElement.querySelector("#edge-layer");
    if (!edgeLayer) {
      edgeLayer = document.createElementNS(SVG_NS, "g");
      edgeLayer.setAttribute("id", "edge-layer");
      const transformLayer = this.svgElement.querySelector("#transform-layer");
      if (transformLayer) {
        const nodeLayer = transformLayer.querySelector("#node-layer");
        if (nodeLayer) {
          transformLayer.insertBefore(edgeLayer, nodeLayer);
        } else {
          transformLayer.appendChild(edgeLayer);
        }
      } else {
        this.svgElement.appendChild(edgeLayer);
      }
    }
    return edgeLayer;
  }
  /**
   * node-layer 획득 또는 생성
   */
  getOrCreateNodeLayer() {
    let nodeLayer = this.svgElement.querySelector("#node-layer");
    if (!nodeLayer) {
      nodeLayer = document.createElementNS(SVG_NS, "g");
      nodeLayer.setAttribute("id", "node-layer");
      const transformLayer = this.svgElement.querySelector("#transform-layer");
      if (transformLayer) {
        transformLayer.appendChild(nodeLayer);
      } else {
        this.svgElement.appendChild(nodeLayer);
      }
    }
    return nodeLayer;
  }
  /**
   * 레이어 내용 제거
   */
  clearLayer(layer) {
    while (layer.firstChild) {
      layer.removeChild(layer.firstChild);
    }
  }
  /**
   * Phase 4.0: 직선(line) 생성
   *
   * 스타일: 하드코딩 (Phase 4.0 임시)
   */
  createLine(from, to) {
    const line = document.createElementNS(SVG_NS, "line");
    line.setAttribute("x1", String(from.x));
    line.setAttribute("y1", String(from.y));
    line.setAttribute("x2", String(to.x));
    line.setAttribute("y2", String(to.y));
    line.setAttribute("stroke", "rgba(0, 0, 0, 0.2)");
    line.setAttribute("stroke-width", "2");
    return line;
  }
  /**
   * 노드 그룹 생성
   *
   * 책임:
   * - CenterRootLayout 결과 좌표를 SVG transform으로 변환
   * - viewBox 기준 좌표계 사용 (transform-layer의 identity transform 기준)
   *
   * 검증:
   * - CenterRootLayout이 계산한 viewport 중앙 좌표가 그대로 적용됨
   * - transform-layer가 identity이므로 추가 변환 없음
   */
  createNodeGroup(id, x, y) {
    console.log("[createNodeGroup] \uCD5C\uC885 \uC88C\uD45C \uC801\uC6A9:", {
      nodeId: id,
      x,
      y,
      transform: `translate(${x}, ${y})`
    });
    const group = document.createElementNS(SVG_NS, "g");
    group.setAttribute("id", `node-${id}`);
    group.setAttribute("transform", `translate(${x}, ${y})`);
    group.setAttribute("data-node-id", id);
    return group;
  }
  /**
   * Phase 6.0: Rounded rect 생성 (circle 대체)
   *
   * 책임:
   * - 텍스트 콘텐츠를 감싸는 rounded rectangle 생성
   * - 선택/드래그 상태에 따른 시각적 피드백
   *
   * @param width - rect 너비
   * @param height - rect 높이
   * @param radius - 모서리 둥글기
   * @param isSelected - 선택 상태
   * @param isDragging - 드래그 상태
   * @returns SVGRectElement
   */
  createRoundedRect(width, height, radius = 8, isSelected = false, isDragging = false) {
    const rect = document.createElementNS(SVG_NS, "rect");
    rect.setAttribute("x", String(-width / 2));
    rect.setAttribute("y", String(-height / 2));
    rect.setAttribute("width", String(width));
    rect.setAttribute("height", String(height));
    rect.setAttribute("rx", String(radius));
    rect.setAttribute("ry", String(radius));
    rect.setAttribute("fill", "rgba(255, 255, 255, 0.9)");
    if (isSelected) {
      rect.setAttribute("stroke", "rgba(0, 122, 255, 1)");
      rect.setAttribute("stroke-width", "3");
    } else {
      rect.setAttribute("stroke", "rgba(0, 0, 0, 0.15)");
      rect.setAttribute("stroke-width", "1");
    }
    if (isDragging) {
      rect.setAttribute("opacity", "0.85");
    }
    return rect;
  }
  /**
   * 텍스트 생성 (단일 줄)
   *
   * 스타일: 하드코딩 (Phase 4.0 임시)
   *
   * @deprecated Phase 6.0부터 createMultilineText() 사용 권장
   */
  createText(content) {
    const text = document.createElementNS(SVG_NS, "text");
    text.setAttribute("x", "0");
    text.setAttribute("y", "0");
    text.setAttribute("text-anchor", "middle");
    text.setAttribute("dominant-baseline", "middle");
    text.setAttribute(
      "font-family",
      "-apple-system, BlinkMacSystemFont, sans-serif"
    );
    text.setAttribute("font-size", "12");
    text.setAttribute("fill", "#1d1d1f");
    text.textContent = content;
    return text;
  }
  /**
   * Phase 6.0: 다중 줄 텍스트 생성 (tspan 기반)
   *
   * 책임:
   * - lines 배열을 tspan 요소로 변환
   * - 수직/수평 중앙 정렬 유지
   * - lineHeight 적용
   *
   * @param lines - 줄바꿈된 텍스트 배열
   * @returns SVGTextElement (tspan 포함)
   */
  createMultilineText(lines) {
    const text = document.createElementNS(SVG_NS, "text");
    text.setAttribute("x", "0");
    text.setAttribute("y", "0");
    text.setAttribute("text-anchor", "middle");
    text.setAttribute(
      "font-family",
      "-apple-system, BlinkMacSystemFont, sans-serif"
    );
    text.setAttribute("font-size", "12");
    text.setAttribute("fill", "#1d1d1f");
    const fontSize = 12;
    const lineHeight = fontSize * 1.4;
    const totalHeight = lines.length * lineHeight;
    const startY = -totalHeight / 2 + lineHeight / 2;
    for (let i = 0; i < lines.length; i++) {
      const tspan = document.createElementNS(
        SVG_NS,
        "tspan"
      );
      tspan.setAttribute("x", "0");
      tspan.setAttribute("y", String(startY + i * lineHeight));
      tspan.setAttribute("dominant-baseline", "middle");
      tspan.textContent = lines[i];
      text.appendChild(tspan);
    }
    return text;
  }
  // =========================================================================
  // Phase 5: Drag 이벤트 핸들러
  // =========================================================================
  /**
   * pointerdown: 드래그 시작 + 노드 선택
   *
   * Phase 5.1:
   * 1. SelectNodeCommand 실행 (노드 선택)
   * 2. draggingNodeId 설정
   * 3. dragOffset 계산 (포인터 위치 - 노드 위치)
   * 4. dragStartPosition 저장 (undo용)
   * 5. 전역 pointermove/pointerup 리스너 등록
   * 6. cursor 변경
   */
  handlePointerDown(e, nodeId, nodePosition) {
    var _a;
    e.stopPropagation();
    if (this.stateManager) {
      this.stateManager.selectNode(nodeId);
    }
    this.draggingNodeId = nodeId;
    this.dragStartPosition = { x: nodePosition.x, y: nodePosition.y };
    const pt = this.svgElement.createSVGPoint();
    pt.x = e.clientX;
    pt.y = e.clientY;
    const svgP = pt.matrixTransform(
      (_a = this.svgElement.getScreenCTM()) == null ? void 0 : _a.inverse()
    );
    this.dragOffset = {
      x: svgP.x - nodePosition.x,
      y: svgP.y - nodePosition.y
    };
    document.addEventListener("pointermove", this.handlePointerMove);
    document.addEventListener("pointerup", this.handlePointerUp);
    document.body.style.cursor = "grabbing";
  }
  /**
   * 렌더링 시작 (현재 미사용)
   */
  start() {
    console.log("Renderer started");
  }
  /**
   * 렌더링 정지
   */
  stop() {
    if (this.rafId !== null) {
      cancelAnimationFrame(this.rafId);
      this.rafId = null;
    }
    console.log("Renderer stopped");
  }
  /**
   * Disposable
   */
  destroy() {
    this.stop();
    document.removeEventListener("pointermove", this.handlePointerMove);
    document.removeEventListener("pointerup", this.handlePointerUp);
  }
};

// src/history/CreateNodeCommand.ts
var CreateNodeCommand = class {
  constructor(node) {
    this.description = "Create node";
    this.parentWasUpdated = false;
    this.node = node;
  }
  execute(context) {
    context.persistent.graph.nodes.set(this.node.id, this.node);
    if (!context.persistent.graph.rootId) {
      context.persistent.graph.rootId = this.node.id;
    }
    if (this.node.parentId) {
      const parent = context.persistent.graph.nodes.get(this.node.parentId);
      if (parent && !parent.childIds.includes(this.node.id)) {
        parent.childIds.push(this.node.id);
        parent.updatedAt = Date.now();
        this.parentWasUpdated = true;
      }
    }
  }
  undo(context) {
    if (this.parentWasUpdated && this.node.parentId) {
      const parent = context.persistent.graph.nodes.get(this.node.parentId);
      if (parent) {
        const index = parent.childIds.indexOf(this.node.id);
        if (index !== -1) {
          parent.childIds.splice(index, 1);
          parent.updatedAt = Date.now();
        }
      }
    }
    context.persistent.graph.nodes.delete(this.node.id);
  }
};

// src/views/NeroMindView.ts
var VIEW_TYPE_NEROMIND = "neromind-view";
var NeroMindView = class extends import_obsidian.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.svgElement = null;
    this.disposables = [];
    this.mindmapContainerEl = null;
    // Phase 3.1: State Management
    this.stateManager = null;
    this.historyManager = null;
    this.eventBus = null;
    this.renderer = null;
    // Phase 3.1: UI Elements
    this.undoButtonEl = null;
    this.plugin = plugin;
  }
  /**
   * 뷰 타입 반환
   */
  getViewType() {
    return VIEW_TYPE_NEROMIND;
  }
  /**
   * 뷰 표시 이름
   */
  getDisplayText() {
    return "NeroMind";
  }
  /**
   * 뷰 아이콘
   */
  getIcon() {
    return "brain";
  }
  /**
   * 뷰 열기
   *
   * Phase 3.1 주의사항:
   * - EventBus → StateManager → HistoryManager 순서
   * - StateManager.setEventBus() 선택적 주입
   * - HistoryManager는 StateManager를 Wrapper로 감싼다
   */
  async onOpen() {
    console.log("Opening NeroMind view...");
    const container = this.containerEl;
    container.empty();
    container.addClass("neromind-view");
    this.mindmapContainerEl = container.createDiv({ cls: "neromind-container" });
    this.initializeSVGCanvas();
    this.initializeStateManagement();
    this.createUndoButton();
    this.registerShortcuts();
    this.registerCanvasEvents();
    this.renderWelcomeMessage();
  }
  /**
   * SVG 캔버스 초기화
   *
   * Phase 6.1 수정사항:
   * - overflow: visible 설정 (clip 방지)
   * - viewBox 제거 (DOM 좌표계와 일치시킴)
   * - 줌/팬은 transform-layer로 처리
   *
   * Phase 1 주의사항:
   * - SVG_NS 네임스페이스 사용 필수
   * - 줌/팬 준비 (transform group)
   */
  initializeSVGCanvas() {
    var _a;
    const SVG_NS2 = "http://www.w3.org/2000/svg";
    this.svgElement = document.createElementNS(SVG_NS2, "svg");
    this.svgElement.setAttribute("class", "neromind-canvas");
    this.svgElement.setAttribute("width", "100%");
    this.svgElement.setAttribute("height", "100%");
    this.svgElement.style.overflow = "visible";
    const bgGroup = document.createElementNS(SVG_NS2, "g");
    bgGroup.setAttribute("id", "background-layer");
    this.svgElement.appendChild(bgGroup);
    const transformGroup = document.createElementNS(SVG_NS2, "g");
    transformGroup.setAttribute("id", "transform-layer");
    transformGroup.setAttribute("transform", "translate(0, 0) scale(1)");
    this.svgElement.appendChild(transformGroup);
    const edgeGroup = document.createElementNS(SVG_NS2, "g");
    edgeGroup.setAttribute("id", "edge-layer");
    transformGroup.appendChild(edgeGroup);
    const nodeGroup = document.createElementNS(SVG_NS2, "g");
    nodeGroup.setAttribute("id", "node-layer");
    transformGroup.appendChild(nodeGroup);
    if (this.mindmapContainerEl) {
      const overlayDiv = this.mindmapContainerEl.createDiv({
        cls: "neromind-overlay"
      });
      overlayDiv.style.position = "absolute";
      overlayDiv.style.top = "0";
      overlayDiv.style.left = "0";
      overlayDiv.style.width = "100%";
      overlayDiv.style.height = "100%";
      overlayDiv.style.pointerEvents = "none";
    }
    (_a = this.mindmapContainerEl) == null ? void 0 : _a.appendChild(this.svgElement);
  }
  /**
   * Phase 3.1: State Management 초기화
   *
   * 책임:
   * - EventBus 생성
   * - StateManager 생성 및 EventBus 주입 (선택적)
   * - HistoryManager 생성 (Wrapper Pattern)
   * - Renderer 생성
   * - disposables 배열에 모두 등록
   *
   * 비책임:
   * - Command 실행
   * - UI 갱신
   */
  initializeStateManagement() {
    this.eventBus = new EventBus();
    this.stateManager = new StateManager();
    this.stateManager.setEventBus(this.eventBus);
    this.addDisposable(this.stateManager);
    this.historyManager = new HistoryManager(this.stateManager);
    this.addDisposable(this.historyManager);
    if (this.svgElement) {
      this.renderer = new Renderer(this.svgElement);
      this.renderer.setStateManager(this.stateManager);
      this.addDisposable(this.renderer);
    }
    console.log("State management initialized");
  }
  /**
   * Phase 3.1: Undo 버튼 생성
   *
   * 책임:
   * - HTML 버튼 요소 생성
   * - CSS 클래스 적용 (styles.css의 .neromind-undo-button 사용)
   * - 클릭 이벤트 연결
   * - 초기 활성화 상태 설정
   *
   * 비책임:
   * - Undo 로직 실행 (handleUndo 책임)
   *
   * z-index 전략:
   * - Undo 버튼은 overlay 내 배치 (z-index: 20)
   * - Canvas transform (zoom/pan)에 영향받지 않음
   * - 노드 렌더링에 가려지지 않음
   */
  createUndoButton() {
    const overlayEl = this.containerEl.querySelector(".neromind-overlay");
    if (!overlayEl) {
      console.warn("Overlay element not found");
      return;
    }
    this.undoButtonEl = overlayEl.createEl("button", {
      text: "Undo",
      cls: "neromind-undo-button"
    });
    this.undoButtonEl.addEventListener("click", () => this.handleUndo());
    this.updateUndoButton();
  }
  /**
   * Phase 3.1: Undo 처리
   *
   * 책임:
   * - canUndo() 확인
   * - historyManager.undo() 호출
   * - snapshot 렌더링
   * - UI 갱신
   * - 에러 처리
   *
   * 비책임:
   * - StateManager 직접 조작
   * - Command 실행 (execute는 사용자 작업용)
   */
  handleUndo() {
    if (!this.historyManager || !this.historyManager.canUndo()) {
      console.log("Cannot undo: no history available");
      return;
    }
    try {
      const snapshot = this.historyManager.undo();
      this.renderSnapshot(snapshot);
      this.updateUndoButton();
      console.log("Undo successful");
    } catch (error) {
      console.error("Undo failed:", error);
    }
  }
  /**
   * Phase 3.1: Undo 버튼 상태 갱신
   *
   * 책임:
   * - canUndo() 결과에 따라 버튼 활성화/비활성화
   * - CSS :disabled 선택자가 자동으로 스타일 적용
   *
   * 비책임:
   * - Undo 로직 실행
   * - 스타일 직접 조작 (CSS에 위임)
   */
  updateUndoButton() {
    if (!this.undoButtonEl || !this.historyManager) {
      return;
    }
    const canUndo = this.historyManager.canUndo();
    this.undoButtonEl.disabled = !canUndo;
  }
  /**
   * Phase 3.4: Snapshot 렌더링
   *
   * 책임:
   * - StateSnapshot을 Renderer에 전달
   * - 콘솔 로깅 (디버깅용)
   *
   * 비책임:
   * - Renderer 내부 로직 수정
   * - StateManager 상태 직접 조작
   */
  renderSnapshot(snapshot) {
    console.log("Rendering snapshot:", {
      nodeCount: snapshot.nodes.length,
      edgeCount: snapshot.edges.length,
      rootId: snapshot.rootId
    });
    if (this.renderer) {
      this.renderer.render(snapshot);
    }
  }
  /**
   * Phase 3.1: 단축키 등록
   *
   * 책임:
   * - Ctrl/Cmd + Z → Undo
   * - 이벤트 전파 방지
   *
   * 비책임:
   * - Redo (Shift + Ctrl/Cmd + Z 금지)
   */
  registerShortcuts() {
    this.registerDomEvent(document, "keydown", (evt) => {
      if ((evt.ctrlKey || evt.metaKey) && evt.key === "z" && !evt.shiftKey) {
        evt.preventDefault();
        this.handleUndo();
      }
    });
  }
  /**
   * Phase 3.3: 캔버스 이벤트 등록
   *
   * 책임:
   * - SVG 캔버스 더블클릭 이벤트 등록
   * - 더블클릭 위치에 노드 생성
   *
   * 비책임:
   * - 렌더링 (Renderer 책임)
   * - 이벤트 발행 (StateManager 책임)
   */
  registerCanvasEvents() {
    if (!this.svgElement) {
      console.warn("SVG element not initialized");
      return;
    }
    this.svgElement.addEventListener("dblclick", (evt) => {
      if (evt instanceof MouseEvent) {
        this.handleCanvasDoubleClick(evt);
      }
    });
  }
  /**
   * Phase 3.3: 캔버스 더블클릭 처리 (실제 사용자 액션)
   *
   * 책임:
   * - 더블클릭 위치 계산
   * - MindMapNode 생성
   * - CreateNodeCommand로 래핑
   * - historyManager.execute() 호출
   *
   * 비책임:
   * - StateManager 직접 조작
   * - 렌더링 (Renderer 책임)
   */
  handleCanvasDoubleClick(evt) {
    if (!this.historyManager || !this.svgElement) {
      console.warn("HistoryManager or SVG element not initialized");
      return;
    }
    const rect = this.svgElement.getBoundingClientRect();
    const x = evt.clientX - rect.left;
    const y = evt.clientY - rect.top;
    const nodeId = `node-${Date.now()}`;
    const newNode = {
      id: nodeId,
      content: "New Node",
      position: { x, y },
      parentId: null,
      childIds: [],
      direction: null,
      isPinned: false,
      isCollapsed: false,
      linkedNotePath: null,
      createdAt: Date.now(),
      updatedAt: Date.now()
    };
    const command = new CreateNodeCommand(newNode);
    try {
      const snapshot = this.historyManager.execute(command);
      console.log("[handleCanvasDoubleClick] \uB178\uB4DC \uC0DD\uC131 - \uD074\uB9AD \uC704\uCE58:", { x, y, nodeId });
      this.renderSnapshot(snapshot);
      this.updateUndoButton();
    } catch (error) {
      console.error("Failed to create node:", error);
    }
  }
  /**
   * Phase 1 환영 메시지
   *
   * Phase 6.1 수정:
   * - viewBox 제거로 인해 getBoundingClientRect() 사용
   * - Renderer.getViewportSize()와 동일한 로직
   * - DOM 좌표계 기준 중앙 계산
   *
   * 검증:
   * ✓ DOM 기준 중앙 계산
   * ✓ Renderer와 동일한 좌표계 사용
   */
  renderWelcomeMessage() {
    const SVG_NS2 = "http://www.w3.org/2000/svg";
    if (!this.svgElement)
      return;
    const nodeLayer = this.svgElement.querySelector("#node-layer");
    if (!nodeLayer)
      return;
    const boundingRect = this.svgElement.getBoundingClientRect();
    const centerX = boundingRect.width / 2 || 400;
    const centerY = boundingRect.height / 2 || 300;
    console.log("[renderWelcomeMessage] DOM \uAE30\uC900 \uC911\uC559 \uACC4\uC0B0:", {
      rectWidth: boundingRect.width,
      rectHeight: boundingRect.height,
      centerX,
      centerY
    });
    const nodeGroup = document.createElementNS(SVG_NS2, "g");
    nodeGroup.setAttribute("transform", `translate(${centerX}, ${centerY})`);
    const rect = document.createElementNS(SVG_NS2, "rect");
    rect.setAttribute("x", "-100");
    rect.setAttribute("y", "-20");
    rect.setAttribute("width", "200");
    rect.setAttribute("height", "40");
    rect.setAttribute("rx", "12");
    rect.setAttribute("fill", "rgba(255, 255, 255, 0.72)");
    rect.setAttribute("stroke", "rgba(0, 0, 0, 0.08)");
    rect.setAttribute("stroke-width", "1");
    rect.setAttribute("filter", "url(#glass-blur)");
    const text = document.createElementNS(SVG_NS2, "text");
    text.setAttribute("x", "0");
    text.setAttribute("y", "5");
    text.setAttribute("text-anchor", "middle");
    text.setAttribute("font-family", "-apple-system, BlinkMacSystemFont, sans-serif");
    text.setAttribute("font-size", "14");
    text.setAttribute("fill", "#1d1d1f");
    text.textContent = "Welcome to NeroMind";
    nodeGroup.appendChild(rect);
    nodeGroup.appendChild(text);
    nodeLayer.appendChild(nodeGroup);
    const defs = document.createElementNS(SVG_NS2, "defs");
    const filter = document.createElementNS(SVG_NS2, "filter");
    filter.setAttribute("id", "glass-blur");
    const feGaussianBlur = document.createElementNS(SVG_NS2, "feGaussianBlur");
    feGaussianBlur.setAttribute("stdDeviation", "10");
    filter.appendChild(feGaussianBlur);
    defs.appendChild(filter);
    this.svgElement.insertBefore(defs, this.svgElement.firstChild);
  }
  /**
   * 뷰 닫기
   *
   * Phase 3.1 주의사항:
   * - disposables 배열이 StateManager, HistoryManager, Renderer 자동 정리
   * - 역순으로 destroy 호출
   * - null 설정으로 메모리 누수 방지
   */
  async onClose() {
    console.log("Closing NeroMind view...");
    const disposablesToDestroy = [...this.disposables].reverse();
    for (const disposable of disposablesToDestroy) {
      try {
        disposable.destroy();
      } catch (error) {
        console.error("Error destroying disposable in view:", error);
      }
    }
    this.disposables = [];
    if (this.svgElement) {
      this.svgElement.remove();
      this.svgElement = null;
    }
    this.stateManager = null;
    this.historyManager = null;
    this.eventBus = null;
    this.renderer = null;
    this.undoButtonEl = null;
  }
  /**
   * Disposable 추가
   */
  addDisposable(disposable) {
    this.disposables.push(disposable);
  }
};

// src/ui/NeroMindSettingTab.ts
var import_obsidian2 = require("obsidian");
var NeroMindSettingTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "NeroMind Settings" });
    containerEl.createEl("p", {
      text: "Settings will be available in Phase 4."
    });
  }
  /**
   * Phase 4: 뷰포트 설정
   */
  addViewportSettings(containerEl) {
    containerEl.createEl("h3", { text: "Viewport" });
    new import_obsidian2.Setting(containerEl).setName("Center on node create").setDesc("Move viewport to center when creating a new node").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.centerOnNodeCreate).onChange(async (value) => {
        this.plugin.settings.centerOnNodeCreate = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian2.Setting(containerEl).setName("Auto align").setDesc("Automatically align nodes to avoid overlapping").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.autoAlign).onChange(async (value) => {
        this.plugin.settings.autoAlign = value;
        await this.plugin.saveSettings();
      })
    );
  }
  /**
   * Phase 4: 미니맵 설정
   */
  addMinimapSettings(containerEl) {
    containerEl.createEl("h3", { text: "Minimap" });
    new import_obsidian2.Setting(containerEl).setName("Show minimap").setDesc("Display minimap in bottom-right corner").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.minimap.enabled).onChange(async (value) => {
        this.plugin.settings.minimap.enabled = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian2.Setting(containerEl).setName("Minimap size").addDropdown(
      (dropdown) => dropdown.addOption("small", "Small").addOption("medium", "Medium").addOption("large", "Large").setValue(this.plugin.settings.minimap.size).onChange(async (value) => {
        this.plugin.settings.minimap.size = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian2.Setting(containerEl).setName("Minimap opacity").addSlider(
      (slider) => slider.setLimits(0.3, 1, 0.1).setValue(this.plugin.settings.minimap.opacity).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.minimap.opacity = value;
        await this.plugin.saveSettings();
      })
    );
  }
  /**
   * Phase 4: 테마 설정
   */
  addThemeSettings(containerEl) {
    containerEl.createEl("h3", { text: "Theme" });
    new import_obsidian2.Setting(containerEl).setName("Theme").setDesc("Choose mindmap theme").addDropdown(
      (dropdown) => dropdown.addOption("light", "Light Mode").addOption("dark", "Dark Mode").addOption("system", "System").setValue(this.plugin.settings.theme).onChange(async (value) => {
        this.plugin.settings.theme = value;
        await this.plugin.saveSettings();
      })
    );
  }
};

// src/main.ts
var NeroMindPlugin = class extends import_obsidian3.Plugin {
  constructor() {
    super(...arguments);
    this.disposables = [];
  }
  /**
   * 플러그인 로드
   *
   * 실행 순서:
   * 1. 설정 로드 (비동기)
   * 2. 뷰 타입 등록
   * 3. 리본 아이콘 추가
   * 4. 설정 탭 등록
   * 5. workspace onLayoutReady 대기 후 초기화
   */
  async onload() {
    console.log("Loading KK-NeroMind plugin...");
    await this.loadSettings();
    this.registerView(
      VIEW_TYPE_NEROMIND,
      (leaf) => new NeroMindView(leaf, this)
    );
    const ribbonIconEl = this.addRibbonIcon(
      "brain",
      "Open NeroMind",
      (evt) => {
        this.activateView();
      }
    );
    ribbonIconEl.addClass("neromind-ribbon-icon");
    this.addSettingTab(new NeroMindSettingTab(this.app, this));
    this.addCommand({
      id: "open-neromind",
      name: "Open NeroMind View",
      callback: () => {
        this.activateView();
      }
    });
    this.app.workspace.onLayoutReady(() => {
      this.initializePlugin();
    });
  }
  /**
   * 플러그인 초기화
   *
   * onLayoutReady 콜백 내에서 실행되어야 함
   * DOM이 완전히 준비된 상태를 보장
   */
  initializePlugin() {
    console.log("Initializing KK-NeroMind plugin...");
  }
  /**
   * 플러그인 언로드
   *
   * Phase 1 주의사항: 역순으로 destroy 호출
   *
   * 향후 destroy 순서 (Phase 2+):
   * 1. Input Layer (InputManager, GlobalShortcutInterceptor)
   * 2. Sync Layer (SyncManager, IntegrityChecker)
   * 3. State Layer (StateManager, CommandHistory)
   * 4. Renderer Layer (Renderer, MiniMapRenderer)
   *
   * 이유: 상위 이벤트 소스부터 차단하여
   *       하위 모듈에 이벤트가 유입되지 않도록 함
   */
  async onunload() {
    console.log("Unloading KK-NeroMind plugin...");
    const disposablesToDestroy = [...this.disposables].reverse();
    for (const disposable of disposablesToDestroy) {
      try {
        disposable.destroy();
      } catch (error) {
        console.error("Error destroying disposable:", error);
      }
    }
    this.disposables = [];
    this.app.workspace.detachLeavesOfType(VIEW_TYPE_NEROMIND);
  }
  /**
   * 설정 로드
   */
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  /**
   * 설정 저장
   */
  async saveSettings() {
    await this.saveData(this.settings);
  }
  /**
   * NeroMind 뷰 활성화
   *
   * 우측 사이드바에 뷰가 없으면 생성
   * 이미 있으면 해당 뷰로 전환
   */
  async activateView() {
    const { workspace } = this.app;
    let leaf = null;
    const leaves = workspace.getLeavesOfType(VIEW_TYPE_NEROMIND);
    if (leaves.length > 0) {
      leaf = leaves[0];
    } else {
      leaf = workspace.getRightLeaf(false);
      if (leaf) {
        await leaf.setViewState({
          type: VIEW_TYPE_NEROMIND,
          active: true
        });
      }
    }
    if (leaf) {
      workspace.revealLeaf(leaf);
    }
  }
};
