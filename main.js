/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => KKNeroMindPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");

// src/schema/types.ts
var CURRENT_SCHEMA_VERSION = 1;

// src/schema/validator.ts
var SchemaValidator = class {
  /**
   * 스키마 검증
   * 
   * @returns true if valid, false otherwise
   */
  validate(data) {
    if (typeof data !== "object" || data === null) {
      console.error("[SchemaValidator] Data is not an object");
      return false;
    }
    const schema = data;
    if (!this.validateSchemaVersion(schema)) {
      return false;
    }
    if (!schema.metadata || !schema.nodes || !schema.edges || !schema.camera) {
      console.error("[SchemaValidator] Missing required top-level fields");
      return false;
    }
    if (!this.validateMetadata(schema.metadata)) {
      return false;
    }
    if (!this.validateNodes(schema.nodes)) {
      return false;
    }
    if (!this.validateEdges(schema.edges, schema.nodes)) {
      return false;
    }
    if (!this.validateCamera(schema.camera)) {
      return false;
    }
    return true;
  }
  /**
   * Sanitize (Phase 1에서는 검증만)
   * 
   * @returns data if valid, null otherwise
   */
  sanitize(data) {
    return this.validate(data) ? data : null;
  }
  /**
   * schemaVersion 검증
   */
  validateSchemaVersion(schema) {
    if (typeof schema.schemaVersion !== "number") {
      console.error("[SchemaValidator] schemaVersion is not a number");
      return false;
    }
    if (!Number.isInteger(schema.schemaVersion)) {
      console.error("[SchemaValidator] schemaVersion must be an integer");
      return false;
    }
    if (schema.schemaVersion <= 0) {
      console.error("[SchemaValidator] schemaVersion must be positive");
      return false;
    }
    if (schema.schemaVersion !== CURRENT_SCHEMA_VERSION) {
      console.error(`[SchemaValidator] Unsupported schema version: ${schema.schemaVersion}`);
      return false;
    }
    return true;
  }
  /**
   * metadata 검증
   * 
   * CRITICAL: 필드명 주의
   * - created (NOT createdAt)
   * - modified (NOT updatedAt)
   * - title (필수)
   */
  validateMetadata(metadata) {
    if (typeof metadata.created !== "number") {
      console.error("[SchemaValidator] metadata.created must be number");
      return false;
    }
    if (typeof metadata.modified !== "number") {
      console.error("[SchemaValidator] metadata.modified must be number");
      return false;
    }
    if (typeof metadata.title !== "string") {
      console.error("[SchemaValidator] metadata.title must be string");
      return false;
    }
    if (metadata.created < 0) {
      console.error("[SchemaValidator] metadata.created must be non-negative");
      return false;
    }
    if (metadata.modified < 0) {
      console.error("[SchemaValidator] metadata.modified must be non-negative");
      return false;
    }
    if (metadata.author !== void 0 && typeof metadata.author !== "string") {
      console.error("[SchemaValidator] metadata.author must be string");
      return false;
    }
    if (metadata.tags !== void 0) {
      if (!Array.isArray(metadata.tags)) {
        console.error("[SchemaValidator] metadata.tags must be array");
        return false;
      }
      for (const tag of metadata.tags) {
        if (typeof tag !== "string") {
          console.error("[SchemaValidator] metadata.tags items must be strings");
          return false;
        }
      }
    }
    return true;
  }
  /**
   * nodes 검증
   */
  validateNodes(nodes) {
    if (typeof nodes !== "object" || nodes === null) {
      console.error("[SchemaValidator] nodes must be an object");
      return false;
    }
    if (Array.isArray(nodes)) {
      console.error("[SchemaValidator] nodes must be Record, not Array");
      return false;
    }
    for (const [key, node] of Object.entries(nodes)) {
      if (!this.validateNode(key, node)) {
        return false;
      }
    }
    return true;
  }
  /**
   * 개별 노드 검증
   */
  validateNode(key, node) {
    if (typeof node.id !== "string") {
      console.error(`[SchemaValidator] Node ${key}: id must be string`);
      return false;
    }
    if (node.id !== key) {
      console.error(`[SchemaValidator] Node ${key}: id mismatch`);
      return false;
    }
    if (typeof node.content !== "string") {
      console.error(`[SchemaValidator] Node ${key}: content must be string`);
      return false;
    }
    if (!this.validatePosition(node.position)) {
      console.error(`[SchemaValidator] Node ${key}: invalid position`);
      return false;
    }
    if (node.size !== void 0) {
      if (!this.validateSize(node.size)) {
        console.error(`[SchemaValidator] Node ${key}: invalid size`);
        return false;
      }
    }
    if (node.style !== void 0) {
      if (typeof node.style !== "object" || node.style === null) {
        console.error(`[SchemaValidator] Node ${key}: style must be object`);
        return false;
      }
      if (Object.keys(node.style).length > 0) {
        console.error(`[SchemaValidator] Node ${key}: style must be empty in v1`);
        return false;
      }
    }
    if (node.linkedNote !== void 0 && typeof node.linkedNote !== "string") {
      console.error(`[SchemaValidator] Node ${key}: linkedNote must be string`);
      return false;
    }
    return true;
  }
  /**
   * position 검증
   */
  validatePosition(position) {
    if (typeof position !== "object" || position === null) {
      return false;
    }
    if (typeof position.x !== "number" || typeof position.y !== "number") {
      return false;
    }
    if (!Number.isFinite(position.x) || !Number.isFinite(position.y)) {
      return false;
    }
    return true;
  }
  /**
   * size 검증
   */
  validateSize(size) {
    if (typeof size !== "object" || size === null) {
      return false;
    }
    if (typeof size.width !== "number" || typeof size.height !== "number") {
      return false;
    }
    if (size.width <= 0 || size.height <= 0) {
      return false;
    }
    return true;
  }
  /**
   * edges 검증
   */
  validateEdges(edges, nodes) {
    if (typeof edges !== "object" || edges === null) {
      console.error("[SchemaValidator] edges must be an object");
      return false;
    }
    if (Array.isArray(edges)) {
      console.error("[SchemaValidator] edges must be Record, not Array");
      return false;
    }
    for (const [key, edge] of Object.entries(edges)) {
      if (!this.validateEdge(key, edge, nodes)) {
        return false;
      }
    }
    return true;
  }
  /**
   * 개별 엣지 검증
   */
  validateEdge(key, edge, nodes) {
    if (typeof edge.id !== "string") {
      console.error(`[SchemaValidator] Edge ${key}: id must be string`);
      return false;
    }
    if (edge.id !== key) {
      console.error(`[SchemaValidator] Edge ${key}: id mismatch`);
      return false;
    }
    if (typeof edge.from !== "string" || typeof edge.to !== "string") {
      console.error(`[SchemaValidator] Edge ${key}: from/to must be strings`);
      return false;
    }
    if (!nodes[edge.from]) {
      console.warn(`[SchemaValidator] Edge ${key}: from node not found (will be sanitized in Phase 2)`);
    }
    if (!nodes[edge.to]) {
      console.warn(`[SchemaValidator] Edge ${key}: to node not found (will be sanitized in Phase 2)`);
    }
    if (edge.type !== void 0) {
      const validTypes = ["solid", "dashed", "dotted"];
      if (!validTypes.includes(edge.type)) {
        console.error(`[SchemaValidator] Edge ${key}: invalid type`);
        return false;
      }
    }
    return true;
  }
  /**
   * camera 검증
   */
  validateCamera(camera) {
    if (typeof camera !== "object" || camera === null) {
      console.error("[SchemaValidator] camera must be an object");
      return false;
    }
    if (typeof camera.x !== "number" || typeof camera.y !== "number" || typeof camera.zoom !== "number") {
      console.error("[SchemaValidator] camera x/y/zoom must be numbers");
      return false;
    }
    if (!Number.isFinite(camera.x) || !Number.isFinite(camera.y) || !Number.isFinite(camera.zoom)) {
      console.error("[SchemaValidator] camera values must be finite");
      return false;
    }
    if (camera.zoom <= 0) {
      console.error("[SchemaValidator] camera.zoom must be positive");
      return false;
    }
    return true;
  }
};

// src/utils/disposable.ts
var DisposableRegistry = class {
  constructor() {
    this.disposables = /* @__PURE__ */ new Set();
  }
  /**
   * Disposable 등록
   */
  register(disposable) {
    this.disposables.add(disposable);
  }
  /**
   * Disposable 등록 해제
   */
  unregister(disposable) {
    this.disposables.delete(disposable);
  }
  /**
   * 모든 Disposable 정리
   * 
   * CRITICAL: 하나 실패해도 나머지 계속 진행
   */
  dispose() {
    const errors = [];
    for (const disposable of this.disposables) {
      try {
        disposable.dispose();
      } catch (error) {
        console.error("[DisposableRegistry] Dispose failed", error);
        errors.push(error);
      }
    }
    this.disposables.clear();
    if (errors.length > 0) {
      console.warn(`[DisposableRegistry] ${errors.length} disposables failed to clean up`);
    }
  }
  /**
   * 등록된 Disposable 개수
   */
  get count() {
    return this.disposables.size;
  }
};

// src/utils/diagnostic.ts
var BootDiagnostics = class {
  constructor() {
    this.modules = /* @__PURE__ */ new Map();
  }
  /**
   * 모듈 상태 등록
   */
  register(moduleId, status, error) {
    const moduleStatus = {
      id: moduleId,
      status,
      error,
      timestamp: Date.now()
    };
    this.modules.set(moduleId, moduleStatus);
    if (status === "success") {
      console.log(`[BootDiagnostics] ${moduleId}: SUCCESS`);
    } else {
      console.error(`[BootDiagnostics] ${moduleId}: FAILED`, error);
    }
  }
  /**
   * 전체 모듈 체크
   */
  checkAllModules() {
    const modules = Array.from(this.modules.values());
    const failedModules = modules.filter((m) => m.status === "failed");
    return {
      success: failedModules.length === 0,
      modules,
      failedCount: failedModules.length
    };
  }
  /**
   * 특정 모듈 상태 조회
   */
  getModuleStatus(moduleId) {
    return this.modules.get(moduleId);
  }
  /**
   * 등록된 모듈 수
   */
  get moduleCount() {
    return this.modules.size;
  }
};

// src/main.ts
var VIEW_TYPE_MINDMAP = "kknm-mindmap-view";
var KKNeroMindPlugin = class extends import_obsidian.Plugin {
  async onload() {
    console.log("[KK-NeroMind] Plugin loading...");
    this.bootDiagnostics = new BootDiagnostics();
    this.disposableRegistry = new DisposableRegistry();
    try {
      this.initializeCore();
      this.bootDiagnostics.register("core-init", "success");
    } catch (error) {
      this.bootDiagnostics.register("core-init", "failed", error);
      this.enterSafeMode();
      return;
    }
    try {
      this.registerCommands();
      this.bootDiagnostics.register("commands", "success");
    } catch (error) {
      this.bootDiagnostics.register("commands", "failed", error);
      this.enterSafeMode();
      return;
    }
    try {
      this.registerExtensions(["kknm"], VIEW_TYPE_MINDMAP);
      this.bootDiagnostics.register("extensions", "success");
    } catch (error) {
      this.bootDiagnostics.register("extensions", "failed", error);
      this.enterSafeMode();
      return;
    }
    const bootResult = this.bootDiagnostics.checkAllModules();
    if (!bootResult.success) {
      console.error("[KK-NeroMind] Boot failed", bootResult);
      this.enterSafeMode();
      return;
    }
    console.log("[KK-NeroMind] Plugin loaded successfully");
  }
  /**
   * Initialize core modules
   */
  initializeCore() {
    this.schemaValidator = new SchemaValidator();
    console.log("[KK-NeroMind] Core modules initialized");
  }
  /**
   * Register commands
   */
  registerCommands() {
    this.addCommand({
      id: "create-new-mindmap",
      name: "Create New Mind Map",
      callback: () => this.createNewMindMap()
    });
    console.log("[KK-NeroMind] Commands registered");
  }
  /**
   * Create new mind map file
   */
  async createNewMindMap() {
    try {
      const initialData = {
        schemaVersion: CURRENT_SCHEMA_VERSION,
        metadata: {
          created: Date.now(),
          // ✅ created
          modified: Date.now(),
          // ✅ modified
          title: "New Mind Map"
          // ✅ title
        },
        nodes: {},
        edges: {},
        camera: { x: 0, y: 0, zoom: 1 }
      };
      if (!this.schemaValidator.validate(initialData)) {
        console.error("[KK-NeroMind] Invalid initial data");
        new import_obsidian.Notice("Failed to create mind map: Invalid data");
        return;
      }
      const content = JSON.stringify(initialData, null, 2);
      const filename = `MindMap-${Date.now()}.kknm`;
      const file = await this.app.vault.create(filename, content);
      const leaf = this.app.workspace.getLeaf(false);
      await leaf.openFile(file);
      new import_obsidian.Notice(`Created: ${filename}`);
      console.log(`[KK-NeroMind] Created: ${filename}`);
    } catch (error) {
      console.error("[KK-NeroMind] Failed to create mind map", error);
      new import_obsidian.Notice("Failed to create mind map");
    }
  }
  /**
   * Enter safe mode (Phase 1에서는 로그만)
   */
  enterSafeMode() {
    console.error("[KK-NeroMind] Entering safe mode - plugin disabled");
    new import_obsidian.Notice("KK-NeroMind: Plugin loaded in safe mode due to boot errors");
  }
  async onunload() {
    console.log("[KK-NeroMind] Plugin unloading...");
    if (this.disposableRegistry) {
      try {
        this.disposableRegistry.dispose();
        console.log("[KK-NeroMind] Resources disposed");
      } catch (error) {
        console.error("[KK-NeroMind] Error during disposal:", error);
      }
    }
    console.log("[KK-NeroMind] Plugin unloaded");
  }
};
