/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => NeroMindPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian2 = require("obsidian");

// src/views/MindMapView.ts
var import_obsidian = require("obsidian");

// src/camera/CoordinateTransformer.ts
var CoordinateTransformer = class {
  /**
   * World 좌표 → Screen 좌표 변환
   * 
   * @param worldX - 월드 좌표 X
   * @param worldY - 월드 좌표 Y
   * @param camera - 카메라 상태
   * @returns Screen 좌표
   */
  worldToScreen(worldX, worldY, camera) {
    return {
      x: worldX * camera.scale + camera.offsetX,
      y: worldY * camera.scale + camera.offsetY
    };
  }
  /**
   * Screen 좌표 → World 좌표 변환
   * 
   * @param screenX - 스크린 좌표 X
   * @param screenY - 스크린 좌표 Y
   * @param camera - 카메라 상태
   * @returns World 좌표
   */
  screenToWorld(screenX, screenY, camera) {
    return {
      x: (screenX - camera.offsetX) / camera.scale,
      y: (screenY - camera.offsetY) / camera.scale
    };
  }
  /**
   * Point 객체를 받는 World → Screen 변환
   */
  worldPointToScreen(worldPoint, camera) {
    return this.worldToScreen(worldPoint.x, worldPoint.y, camera);
  }
  /**
   * Point 객체를 받는 Screen → World 변환
   */
  screenPointToWorld(screenPoint, camera) {
    return this.screenToWorld(screenPoint.x, screenPoint.y, camera);
  }
};

// src/camera/CameraController.ts
var CameraController = class {
  constructor(containerEl, initialCamera) {
    this.containerEl = containerEl;
    // 잠금 메커니즘
    this.lockCount = 0;
    // ResizeObserver
    this.resizeObserver = null;
    var _a, _b, _c;
    this.camera = {
      offsetX: (_a = initialCamera == null ? void 0 : initialCamera.offsetX) != null ? _a : 0,
      offsetY: (_b = initialCamera == null ? void 0 : initialCamera.offsetY) != null ? _b : 0,
      scale: (_c = initialCamera == null ? void 0 : initialCamera.scale) != null ? _c : 1
    };
    this.viewport = {
      width: containerEl.clientWidth,
      height: containerEl.clientHeight
    };
    this.transformer = new CoordinateTransformer();
    this.setupResizeObserver();
  }
  /**
   * ResizeObserver 설정
   */
  setupResizeObserver() {
    this.resizeObserver = new ResizeObserver((entries) => {
      for (const entry of entries) {
        this.onResize(entry.contentRect);
      }
    });
    this.resizeObserver.observe(this.containerEl);
  }
  /**
   * Resize 처리
   *
   * 규칙:
   * - 화면 중앙의 월드 좌표를 유지
   * - 카메라 잠금 시 무시
   */
  onResize(newRect) {
    if (this.isLocked()) {
      console.log("Resize ignored: camera locked");
      return;
    }
    const centerWorld = this.transformer.screenToWorld(
      this.viewport.width / 2,
      this.viewport.height / 2,
      this.camera
    );
    this.viewport = {
      width: newRect.width,
      height: newRect.height
    };
    this.applyCameraChange(
      {
        offsetX: this.viewport.width / 2 - centerWorld.x * this.camera.scale,
        offsetY: this.viewport.height / 2 - centerWorld.y * this.camera.scale
      },
      "ResizeAdjustment" /* ResizeAdjustment */
    );
  }
  /**
   * 카메라 상태 변경 (단일 진입점)
   *
   * ⚠️ 모든 카메라 변경은 반드시 이 메서드를 통해야 함
   *
   * @param partial - 변경할 카메라 속성 (부분 업데이트 가능)
   * @param reason - 변경 사유 (로깅 및 디버깅용)
   * @returns 변경 성공 여부
   */
  applyCameraChange(partial, reason) {
    var _a;
    if (this.isLocked() && reason !== "InitialViewport" /* InitialViewport */) {
      console.warn(
        `Camera change blocked: ${this.currentLockReason}, attempted: ${reason}`
      );
      return false;
    }
    console.log(`Camera change: ${reason}`, partial);
    this.camera = { ...this.camera, ...partial };
    this.camera.scale = this.clampScale(this.camera.scale);
    (_a = this.onCameraChanged) == null ? void 0 : _a.call(this, { ...this.camera });
    return true;
  }
  /**
   * 카메라 잠금
   *
   * @param reason - 잠금 사유
   */
  lock(reason) {
    var _a;
    this.lockCount++;
    this.currentLockReason = reason;
    console.log(`Camera locked: ${reason} (count: ${this.lockCount})`);
    (_a = this.onLockChanged) == null ? void 0 : _a.call(this, true, reason);
  }
  /**
   * 카메라 잠금 해제
   *
   * @param reason - 잠금 사유 (로깅용)
   */
  unlock(reason) {
    var _a;
    this.lockCount = Math.max(0, this.lockCount - 1);
    if (this.lockCount === 0) {
      this.currentLockReason = void 0;
      console.log(`Camera unlocked: ${reason}`);
      (_a = this.onLockChanged) == null ? void 0 : _a.call(this, false);
    }
  }
  /**
   * 카메라 잠금 여부
   */
  isLocked() {
    return this.lockCount > 0;
  }
  /**
   * 현재 카메라 상태 조회 (읽기 전용)
   */
  getCamera() {
    return { ...this.camera };
  }
  /**
   * 현재 뷰포트 조회 (읽기 전용)
   */
  getViewport() {
    return { ...this.viewport };
  }
  /**
   * 좌표 변환기 조회
   */
  getTransformer() {
    return this.transformer;
  }
  /**
   * 렌더러 콜백 등록
   *
   * @param callback - 카메라 변경 시 호출될 콜백
   */
  onCameraChange(callback) {
    this.onCameraChanged = callback;
  }
  /**
   * 잠금 상태 변경 콜백 등록
   *
   * @param callback - 잠금 상태 변경 시 호출될 콜백
   */
  onLockChange(callback) {
    this.onLockChanged = callback;
  }
  /**
   * scale 범위 제한 (0.1 ~ 5.0)
   */
  clampScale(scale) {
    return Math.max(0.1, Math.min(5, scale));
  }
  /**
   * 리소스 정리
   */
  destroy() {
    if (this.resizeObserver) {
      this.resizeObserver.disconnect();
      this.resizeObserver = null;
    }
    this.onCameraChanged = void 0;
  }
};

// src/views/MindMapView.ts
var VIEW_TYPE_NEROMIND = "neromind-view";
var MindMapView = class extends import_obsidian.ItemView {
  constructor(leaf) {
    super(leaf);
    this.cameraController = null;
    this.svgEl = null;
    this.transformLayer = null;
  }
  /**
   * 뷰 타입 반환
   */
  getViewType() {
    return VIEW_TYPE_NEROMIND;
  }
  /**
   * 뷰 표시 이름
   */
  getDisplayText() {
    return "NeroMind";
  }
  /**
   * 뷰 아이콘
   */
  getIcon() {
    return "brain";
  }
  /**
   * 뷰 열림
   */
  async onOpen() {
    const container = this.containerEl.children[1];
    container.empty();
    container.addClass("neromind-container");
    this.createSVGCanvas(container);
    this.cameraController = new CameraController(container);
    this.cameraController.onCameraChange((camera) => {
      this.updateTransform(camera);
    });
    const viewport = this.cameraController.getViewport();
    this.cameraController.applyCameraChange(
      {
        offsetX: viewport.width / 2,
        offsetY: viewport.height / 2,
        scale: 1
      },
      "InitialViewport" /* InitialViewport */
    );
    this.renderStub();
  }
  /**
   * SVG 캔버스 생성
   */
  createSVGCanvas(container) {
    this.svgEl = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    this.svgEl.addClass("neromind-canvas");
    this.svgEl.setAttribute("width", "100%");
    this.svgEl.setAttribute("height", "100%");
    this.transformLayer = document.createElementNS("http://www.w3.org/2000/svg", "g");
    this.transformLayer.setAttribute("id", "transform-layer");
    this.svgEl.appendChild(this.transformLayer);
    container.appendChild(this.svgEl);
  }
  /**
   * Transform 업데이트
   * 
   * 규칙:
   * - SVG transform-layer에만 카메라 적용
   * - 노드 좌표는 월드 좌표 그대로 유지
   */
  updateTransform(camera) {
    if (!this.transformLayer)
      return;
    this.transformLayer.setAttribute(
      "transform",
      `translate(${camera.offsetX}, ${camera.offsetY}) scale(${camera.scale})`
    );
  }
  /**
   * Stub 렌더링 (Phase 1 P0)
   * 
   * 목적:
   * - CameraController 동작 확인
   * - 좌표 변환 검증
   */
  renderStub() {
    if (!this.transformLayer)
      return;
    const origin = document.createElementNS("http://www.w3.org/2000/svg", "circle");
    origin.setAttribute("cx", "0");
    origin.setAttribute("cy", "0");
    origin.setAttribute("r", "10");
    origin.setAttribute("fill", "#ff3b30");
    const xAxis = document.createElementNS("http://www.w3.org/2000/svg", "line");
    xAxis.setAttribute("x1", "0");
    xAxis.setAttribute("y1", "0");
    xAxis.setAttribute("x2", "100");
    xAxis.setAttribute("y2", "0");
    xAxis.setAttribute("stroke", "#007AFF");
    xAxis.setAttribute("stroke-width", "2");
    const yAxis = document.createElementNS("http://www.w3.org/2000/svg", "line");
    yAxis.setAttribute("x1", "0");
    yAxis.setAttribute("y1", "0");
    yAxis.setAttribute("x2", "0");
    yAxis.setAttribute("y2", "100");
    yAxis.setAttribute("stroke", "#34C759");
    yAxis.setAttribute("stroke-width", "2");
    const testNode = document.createElementNS("http://www.w3.org/2000/svg", "rect");
    testNode.setAttribute("x", "80");
    testNode.setAttribute("y", "80");
    testNode.setAttribute("width", "40");
    testNode.setAttribute("height", "40");
    testNode.setAttribute("rx", "8");
    testNode.setAttribute("fill", "rgba(255, 255, 255, 0.72)");
    testNode.setAttribute("stroke", "#007AFF");
    testNode.setAttribute("stroke-width", "2");
    this.transformLayer.appendChild(origin);
    this.transformLayer.appendChild(xAxis);
    this.transformLayer.appendChild(yAxis);
    this.transformLayer.appendChild(testNode);
  }
  /**
   * 뷰 닫힘
   */
  async onClose() {
    if (this.cameraController) {
      this.cameraController.destroy();
      this.cameraController = null;
    }
    this.svgEl = null;
    this.transformLayer = null;
  }
};

// src/main.ts
var DEFAULT_SETTINGS = {
  version: "0.1.0"
};
var NeroMindPlugin = class extends import_obsidian2.Plugin {
  constructor() {
    super(...arguments);
    this.settings = DEFAULT_SETTINGS;
    this.disposables = [];
  }
  /**
   * 플러그인 로드
   */
  async onload() {
    console.log("Loading KK-NeroMind Plugin");
    await this.loadSettings();
    this.registerView(
      VIEW_TYPE_NEROMIND,
      (leaf) => new MindMapView(leaf)
    );
    this.addRibbonIcon("brain", "Open NeroMind", () => {
      this.activateView();
    });
    this.addCommand({
      id: "open-neromind-view",
      name: "Open NeroMind View",
      callback: () => {
        this.activateView();
      }
    });
    this.app.workspace.onLayoutReady(() => {
      console.log("NeroMind: Layout ready");
    });
  }
  /**
   * 플러그인 언로드
   */
  async onunload() {
    console.log("Unloading KK-NeroMind Plugin");
    for (const disposable of this.disposables.reverse()) {
      disposable.destroy();
    }
    this.disposables = [];
    this.app.workspace.detachLeavesOfType(VIEW_TYPE_NEROMIND);
  }
  /**
   * 설정 로드
   */
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  /**
   * 설정 저장
   */
  async saveSettings() {
    await this.saveData(this.settings);
  }
  /**
   * MindMapView 활성화
   */
  async activateView() {
    const { workspace } = this.app;
    let leaf = workspace.getLeavesOfType(VIEW_TYPE_NEROMIND)[0];
    if (!leaf) {
      const rightLeaf = workspace.getRightLeaf(false);
      if (rightLeaf) {
        await rightLeaf.setViewState({
          type: VIEW_TYPE_NEROMIND,
          active: true
        });
        leaf = rightLeaf;
      }
    }
    if (leaf) {
      workspace.revealLeaf(leaf);
    }
  }
  /**
   * Disposable 등록
   * 
   * @param disposable - 정리가 필요한 객체
   */
  registerDisposable(disposable) {
    this.disposables.push(disposable);
  }
};
